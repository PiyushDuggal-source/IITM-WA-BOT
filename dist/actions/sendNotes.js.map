{
  "version": 3,
  "sources": ["../../src/actions/sendNotes.ts"],
  "sourcesContent": ["import * as WAWebJS from \"whatsapp-web.js\";\nimport { BOT } from \"..\";\nimport { NOTES } from \"../resources/notes\";\nimport { MessageType } from \"../types/types\";\nimport { FOOTERS } from \"../utils/reply/footers\";\nimport { GREETINGS, HEY_EMOJIES } from \"../utils/reply/replies\";\nimport { sendAndDeleteMsg } from \"./sendAndDeleteMsg\";\nimport { random } from \"./sendMessage\";\n\nlet adminMsg = `*These are the Notes ${\n  GREETINGS.admin[random(GREETINGS.adminMsgNumber)]\n}* ${HEY_EMOJIES[random(HEY_EMOJIES.length)]}`;\n\nlet userMsg = `*These are the Notes ${\n  GREETINGS.member[random(GREETINGS.memberMsgNumber)]\n}* ${\n  HEY_EMOJIES[random(HEY_EMOJIES.length)]\n}\\n\\n*Use filter if you want specific subject's notes*\\nEg: *!notes {SubjectName}*\\n\\nNote: _I am not connected, associated, affiliated with any of the Owners of these links to Promote, Encourage any Channel/Group, I found the links on internet only._`;\n// }\\n\\n`;\n\nexport const sendNotes = async (\n  client: WAWebJS.Client,\n  messageInstance: WAWebJS.Message,\n  who: MessageType\n) => {\n  let content = who === \"ADMIN\" ? adminMsg : userMsg;\n  content += `\\n\\n: ${FOOTERS.footers[random(FOOTERS.footerMsgLength)]}`;\n  NOTES.forEach((note) => {\n    content += `\\n\\n*_NAME_* : *${note.name}*\\n\\n -----------*Content*------------`;\n    note.content.forEach((noteContent) => {\n      content += `\\n\\nName of the Content: _${noteContent.name}_\\nLink: ${noteContent.link}`;\n    });\n  });\n  if (who === \"ADMIN\") {\n    const chats = await client.getChats();\n    const bot = chats[BOT];\n    bot.sendMessage(content);\n  } else if (who !== \"NONE\") {\n    sendAndDeleteMsg(client, messageInstance, who, content);\n  }\n};\n\nconst sorryMsg = `Sorry ${\n  GREETINGS.member[random(GREETINGS.memberMsgNumber)]\n}\\nOnly one word is allowed after !notes command ${\n  HEY_EMOJIES[random(HEY_EMOJIES.length)]\n}`;\n\nconst invalidMsg =\n  \"The filter is invalid or notes are not updated with the respective subject, please wait for a while we will upload the respective notes soon\";\n\nexport const sendNotesByFilter = async (\n  client: WAWebJS.Client,\n  messageBody: string,\n  messageInstance: WAWebJS.Message,\n  who: MessageType\n) => {\n  const msgList = messageBody.split(\" \");\n\n  if (who === \"ADMIN\") {\n    const chats = await client.getChats();\n    const bot = chats[BOT];\n    if (msgList.length > 2) {\n      bot.sendMessage(sorryMsg);\n    } else {\n      // First check in the Contents\n      const filteredNotes = NOTES.map((note) =>\n        note.content.filter((not) =>\n          not.name.toLocaleLowerCase().includes(msgList[1].toLocaleLowerCase())\n        )\n      );\n\n      // If not in the content, check in the upper names\n      if (!filteredNotes.flat().length) {\n        const filteredNotes = NOTES.filter((note) =>\n          note.name.toLocaleLowerCase().includes(msgList[1].toLocaleLowerCase())\n        );\n        let content = userMsg;\n        filteredNotes.forEach((note) => {\n          content += `\\n\\n*_NAME_* : *${note.name}*\\n\\n -----------*Content*------------`;\n          note.content.forEach((noteContent) => {\n            content += `\\n\\nName of the Content: _${noteContent.name}_\\nLink: ${noteContent.link}`;\n          });\n        });\n\n        if (!filteredNotes.length) {\n          bot.sendMessage(invalidMsg);\n        } else {\n          content += `\\n\\n: ${\n            FOOTERS.footers[random(FOOTERS.footerMsgLength)]\n          }`;\n          bot.sendMessage(content);\n        }\n      } else {\n        let content = userMsg;\n        filteredNotes.forEach((note) => {\n          note.forEach((not) => {\n            content += `\\n\\nName of the Content: _${not.name}_\\nLink: ${not.link}`;\n          });\n        });\n        content += `\\n\\n: ${FOOTERS.footers[random(FOOTERS.footerMsgLength)]}`;\n        bot.sendMessage(content);\n      }\n    }\n  } else if (who !== \"NONE\") {\n    if (msgList.length > 2) {\n      sendAndDeleteMsg(client, messageInstance, who, sorryMsg);\n    } else {\n      // First check in the Contents\n      const filteredNotes = NOTES.map((note) =>\n        note.content.filter((not) =>\n          not.name.toLocaleLowerCase().includes(msgList[1].toLocaleLowerCase())\n        )\n      );\n\n      // If not in the content, check in the upper names\n      if (!filteredNotes.flat().length) {\n        const filteredNotes = NOTES.filter((note) =>\n          note.name.toLocaleLowerCase().includes(msgList[1].toLocaleLowerCase())\n        );\n        let content = userMsg;\n        filteredNotes.forEach((note) => {\n          content += `\\n\\n*_NAME_* : *${note.name}*\\n\\n -----------*Content*------------`;\n          note.content.forEach((noteContent) => {\n            content += `\\n\\nName of the Content: _${noteContent.name}_\\nLink: ${noteContent.link}`;\n          });\n        });\n\n        if (!filteredNotes.length) {\n          sendAndDeleteMsg(client, messageInstance, who, invalidMsg);\n        } else {\n          content += `\\n\\n: ${\n            FOOTERS.footers[random(FOOTERS.footerMsgLength)]\n          }`;\n          sendAndDeleteMsg(client, messageInstance, who, content);\n        }\n      } else {\n        let content = userMsg;\n        filteredNotes.forEach((note) => {\n          note.forEach((not) => {\n            content += `\\n\\nName of the Content: _${not.name}_\\nLink: ${not.link}`;\n          });\n        });\n        content += `\\n\\n: ${FOOTERS.footers[random(FOOTERS.footerMsgLength)]}`;\n        sendAndDeleteMsg(client, messageInstance, who, content);\n      }\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
